# JSer！汝何锈？

但凡程序员，总是要生锈的，或主动，或被动，谁都躲不过。前端程序员对锈（Rust）肯定不陌生，在我这个很小的朋友圈里，竟然有一大堆锈儿。虽在意料之外，却也在情理之中。毕竟，Rust 与前端世界可谓渊源颇深。

Rust 诞生于著名的浏览器厂商 Mozilla，没错，就是创立 MDN 的那个 Mozilla。当然，它还有一个更重要的身份，就是当今世界主要的浏览器内核之一 FireFox 的创立者和维护者。Mozilla 最初创立 Rust 的目的之一，就是用它代替 C++ 来编写 FireFox，根据 2022 年的公开数据，FireFox 已经有 20% 的代码从 C++ 重构成了 Rust。我们软件业有一个著名的原则：“如果还能用，那就不要动”，显然，Mozilla 选择把一个运行得很好的软件重构成 Rust 版本，一定有一些非同寻常的理由，或者说，Rust 一定有某些超乎寻常的优点才能让 Mozilla 下这么大的决心。

接下来，我们就来分析下这些理由。

## 安全，安全，还是 TMD 安全

这是最重要也最不可或缺的一条。从这个角度看，FireFox 远远称不上“运行得很好”，而另一个主流浏览器 Chrome 其实跟它也是难兄难弟。

我们知道，互联网一直都是黑客攻击的重灾区，很多著名的安全事件都发生在互联网上。浏览器自身的安全漏洞很多，比如 OpenSSL Heartbleed 漏洞、Pwn2Own 漏洞、FireFox Visitors 漏洞、Chrome Heap buffer overflow 漏洞等。这些漏洞都可以被恶意攻击者利用，让人在浏览网页时不知不觉间就中招了。

而这些底层漏洞，绝大多数都跟一个问题有关，那就是内存管理。根据 Google 披露的数据，Chrome 的安全漏洞中有 70% 跟内存管理有关！可以说，解决了内存管理问题，就能显著提升浏览器这种互联网基础设施的安全等级。但 Mozilla 和 Google 为什么不做呢？是不喜欢吗？显然不是，因为安全关系到每个公司的声誉！不做只是因为“太贵了！”，C++ 是以灵活著称的语言，它很少对程序员施加限制，就像一个没有扶手的楼梯，你可以随便走，但是防止你摔下去可不是它的责任。有些人喜欢它的灵活，但大部分人却并没有这样的能力。如果你以前写过 C++，也许会觉得自己属于另外一小部分天命之子，但请相信我，这只是幻觉。不客气的说，可能任何人类都没有这样的能力。因为需要让程序员完成这样不可能的任务，所以想让 C++ 实现内存安全就要付出极大的成本 —— 而且这还不一定能奏效。

俗话说，常在河边走，哪有不湿鞋。一位老司机不会觉得把车停得离悬崖越近越能体现自己的能力，同样，一位资深程序员也不会觉得在危险的边缘疯狂试探是值得骄傲的资本。

所以，请让 Rust 为你的楼梯装上护栏！这可能就是 Mozilla 做出这项重大决策的首要理由。

Rust 引入了所有权的概念来让内存受到严格管控，避免了 Stack Overflow（栈溢出）、使用未初始化内存等常见漏洞类型。当然，这个概念对于前端程序员来讲，确实是一个新事物，需要花费一定的心力去掌握。但它值得。因为即使你不做浏览器底层开发，仍然有一些场景需要用到 Rust，这来自 Rust 的另一些优点。

## 快一点，快一点，再快一点

前端圈有很多瓜，前一阵子最多的瓜可能就是工具链性能竞赛了。不断有新秀构建工具（比如 Rspack）号称比 Webpack 快十倍百倍，这些新闻背后的技术，可能大部分都是 Rust。

性能是 Rust 的另一个关注点。如果仔细分析，性能至少包括两个方面：资源占用和运行速度。从资源占用来看，Rust 不需要自己的运行时环境。因此对于小型程序，Rust 对各种资源可谓物尽其用；虽然对大型程序来说运行时环境的内存占用只是九牛一毛，但不需要运行时环境节省出来的执行开销也能让程序显著受益。

Rust 针对性能做了很多设计优化。

Rust 的主要设计目标之一是零成本抽象，也就是说不需要借助额外的内存占用和执行代码，即可实现对事物的抽象建模。这对于很少接触系统编程的 JSer 来说可能有些难以理解，你只需要知道像 JS 这样的语言，为了实现各种高级抽象能力是需要付出很多成本的，比如垃圾回收器等，但 Rust 通过某种特殊的设计方案，避免了这部分成本。而它的外在表现，则是 Rust 无论在内存占用还在执行速度方面都显著优于 JS。

除此之外，在 Rust 中，通常并不会操纵字符串，而是要操纵由“字符串地址，起始偏移，长度”组成的数据结构（`&str`，学名为引用/胖指针），这种数据结构只是字符串本身的一个视图，通常都不会导致内存的分配与释放，从而省去了很多内存管理的时间开销。这种设计思想也用在了很多地方，比如对数组、向量的操作。因此，对于像构建工具链这样要求追求性能的程序，Rust 是一个很好的选择。

普遍来说，在 Rust 中，会优先使用栈操作而非堆操作。如果你了解计算机体系结构就会知道，在栈上分配内存只需要修改栈顶地址即可，而在堆上分配内存则会涉及到比较复杂的堆空间管理算法。

此外，Rust 还使用了一些 JSer 普遍不熟悉的高级技术来提升程序的性能（如并发模型、编译器优化、内联等），这里就先不展开论述了。

除了节省内存和运行时间之外，没有运行时环境还带来一个额外的优点，那就是 Rust 编译出的程序不需要安装任何运行期依赖。比如 NodeJS 程序需要安装 NodeJS 运行时，Java 程序需要安装 JRE，而 Rust 程序不需要类似的环境。可以直接针对目标环境编译出二进制文件，只要和必要的动态链接库一起复制到目标系统就能正常运行了。

## 一个平台，两个平台，n 个平台……

Rust 在设计之初就定位为跨平台语言，对于新语言来说，这并不稀奇。稀奇的是它对“平台”的定义有些特别。

这里就不得不提到 Mozilla 创立的另一项技术了，那就是 WebAssembly。JSer 对它可能并不陌生，但大多数人可能并没有实际用过。

WebAssembly 是一种跨平台的低级字节码格式，其目的是在 Web 浏览器中提供高性能的执行环境。而 Rust 则是最早支持 WebAssembly 的语言之一，甚至可以说两者的演化息息相关。除了两者都来自 Mozilla 之外，更重要的原因是“安全”、“性能”、“跨平台”等都是它们共同的目标。

Rust 具有开箱即用的 WebAssembly 支持，它的编译器可以直接把 Rust 代码编译为 WebAssembly 模块。除此之外，它还有一个相当完整的 WebAssembly 生态并且可以借助对 JavaScript 互操作的支持与 JavaScript 生态整合在一起。众所周知，JavaScript 虽然经历过很多轮的性能优化，但在要求极致性能的场景下仍然难以胜任（比如图形学、游戏、边缘计算等）。而 Rust 和 WebAssembly 的组合很好地补上了这块短板，可以预期，Rust 和 WebAssembly 的流行，必将解除一些应用场景在 Web 平台上的封印。

如今的 WebAssembly 已然出圈，开始走入了服务器端，开始部分替代 Docker 的职能，Rust 自然也搭上了这趟便车。

WebAssembly 仍然运行在计算资源比较丰富的硬件平台上，但还有很多平台的计算资源非常贫乏。典型的就是各种嵌入式系统，比如 VxWorks。JSer 对这些平台可能不太了解，但至少应该听说过物联网这个词吧？现在的共享单车就是物联网的典型应用之一，而在生活之外还有很多看不见的物联网应用，比如智能矿山等。这些平台传统上都使用 C/C++ 进行编程，但 C/C++ 的安全性是巨大的隐患，如果物联网应用的安全漏洞被恶意利用，损失的可能就不是钱，而是生命。可以预见，随着物联网迅速走入人们的生活，安全性会变得前所未有的重要，对于 C/C++ 技术栈来说，这是一个普遍存在的短板，而 Rust 可以帮你补上它。

## 走出来！

子曰：“君子不器”！作为有技术追求的程序员，我们不能在舒适圈画地为牢，而应该多走出来看看，Rust 很适合作为迈出去的第一步。一方面，它在前端工具链领域正当红，在 WebAssembly 领域也是明日之星，正是你建功立业的好时机；另一方面，探索前端之外的领域，分散风险，在这个急剧变化的时代也非常有必要。更何况，Rust 是 Web 祖师爷 Mozilla 全力打造的技术，还受到了互联网巨头们的热捧。

掌握这项技术虽然需要付出不少的努力，但也会给你带来丰厚的回报。千里之行，始于足下，机会稍纵即逝，请不要再犹豫了。
